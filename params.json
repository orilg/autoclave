{"google":"","name":"Autoclave","tagline":"A skeleton for flask-based apps, for rapid development and deployment","body":"Autoclave\r\n=========\r\n\r\nAutoclave is a ready-to-deploy skeleton for building in-house web-based apps. Its goal is to provide a \"batteries included\" approach for rapid webapp development for small/medium scale apps.\r\n\r\nAutoclave includes:\r\n\r\n* A fabric file that can deploy the app to your (preferably dedicated) Ubuntu-based server, as well as rapidly build a test environment on your local machine\r\n* A backend implemented in Python using the [Flask](http://flask.pocoo.org) framework, running on top of [gevent](http://www.gevent.org/)\r\n* A MongoDB database engine (deployed to the same server by default)\r\n* A Redis instance (deployed to the same server by default)\r\n* A Celery/Celerybeat worker, along with a RabbitMQ broker, to easily support background operations carried out by your app\r\n* An *nginx* frontend proxying your app and serving static files.\r\n* A stylesheet overlaying [Twitter Bootstrap](http://twitter.github.com/bootstrap/)\r\n* jQuery ready to use, along with [pnotify](http://pinesframework.org/pnotify/) notifications\r\n* A server-side utility library for rapidly implementing REST api's over HTTP with JSON encapsulation\r\n\r\nGetting Started\r\n===============\r\n\r\n1. Clone the autoclave repository to your development environment. Let's say you put it in `~/autoclave`.\r\n2. Install dependencies: `pip install -r ~/autoclave/pip_requirements`\r\n3. To debug autoclave, you'll need `tmux`, `redis`, `mongodb`, `rabbitmq` and `nginx`.\r\n4. Chdir into the directory, and run your first instance: `fab debug`. This will bring up *tmux* with several panes, one for each running service.\r\n5. Open your browser and point it to *http://127.0.0.1:8080*, and voilla!\r\n\r\nChecklist for Starting an App\r\n=============================\r\n\r\n1. Change your app name in `flask_app/config/app.py -> APP_NAME`.\r\n\r\nDeploying to a Server\r\n=====================\r\n\r\n> *NOTE*: The automated deployment assumes there are no other critical services running on the server\r\n\r\nTo deploy your app, just run `fab deploy`:\r\n\r\n   fab deploy -H your_host -u root -p yourpassword\r\n\r\n**NOTE**: you'll need to have `fabtools` installed to run the fabric file. It is automatically installed in the debug steps above, but necessary if you skip them.\r\n\r\nWhat's Inside?\r\n==============\r\n\r\nHTML, CSS\r\n---------\r\n\r\nAutoclave includes the excellent Twitter Bootsrap by default. You can add and override styles by editing `static_src/style.less` and rebuilding the CSS with `fab compile_css`.\r\n\r\nData Storage with MongoDB\r\n-------------------------\r\n\r\nTo get a MongoDB connection (via Pymongo):\r\n\r\n from .db import get_connection\r\n connection = get_connection()\r\n connection[\"my_db\"][\"my_collection\"].find({\"field\" : \"value\"})\r\n\r\nCaching, Key-Value Store and IPC with Redis\r\n-------------------------------------------\r\n\r\nFor many use cases like distributed locking, caching etc. Redis is extremely useful. Autoclave includes Redis, and a working binding:\r\n\r\n from .redis import get_connection\r\n connection = get_connection() # a redis-py StrictRedis connection\r\n connection.set(\"key\", \"value\")\r\n\r\nBackground Tasks with Celery\r\n----------------------------\r\n\r\nYou can easily add background tasks to your webapp by editing `flask_app/tasks.py`. For instance, you can add:\r\n\r\n @celery.task\r\n def test_task():\r\n     time.sleep(5)\r\n\r\nFor more information on how to fire your task, refer to the [Celery documentation](http://www.celeryproject.org/docs-and-support/).\r\n\r\nJavascript\r\n----------\r\n\r\n### Notifications\r\n\r\nNotifications can be easily achieved like so:\r\n\r\n autoclave.notify_info(\"Hey there!\");\r\n\r\nOr alternatively:\r\n\r\n autoclave.notify(\"Hello\", \"error\");\r\n\r\nAvailable notification types are \"error\", \"warning\", \"info\" and \"success\", as in [pnotify](http://pinesframework.org/pnotify/).\r\n\r\n### API\r\n\r\nMaking your app's client-side code call into the backend via a clean API doesn't have to be a mess. Define your API as a Python function decorated with the `api_handler` decorator:\r\n\r\n  from .api import api_handler\r\n\r\n  @api_handler(\"/format_string_and_two_numbers\", string=str, a=int, b=int)\r\n  def format(string, a, b):\r\n      return {\"result\" : \"{}{}{}\".format(string, a, b)}\r\n\r\nAnd your function will be accessible for POSTing through *<API ROOT>*/format_string_and_two_numbers. (API ROOT is set with API_ROOT in the configuration file). Calling your function is done by posting a JSON dict with the arguments to the specified URL, and the returned JSON is the exact dict returned by the function. Adding code that calls this from your app's client-side Javascript is easy:\r\n\r\n  autoclave.api.call(\"/api/format_string_and_two_numbers\", {\"string\" : \"hello\", \"a\" : 2, \"b\", 3})\r\n     .success(function(data) {\r\n         autoclave.notify_success(\"Result is \" + data.result)\r\n     });\r\n\r\nAlso, Autoclave provides the @returns_json decorator for views that want to return simple Pythonic values to be translated into JSON automatically.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}